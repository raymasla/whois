<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èª°æ˜¯è‡¥åº• - ç°¡æ˜“ç‰ˆ</title>
    <style>
        :root {
            /* æš—é»‘æ¨¡å¼é…è‰²è®Šæ•¸ */
            --primary: #3498db;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --bg: #121212;        /* æ·±è‰²èƒŒæ™¯ */
            --card: #1e1e1e;      /* å¡ç‰‡èƒŒæ™¯ */
            --text: #e0e0e0;      /* ä¸»è¦æ–‡å­— */
            --text-muted: #a0a0a0;
            --border: #333333;
            --input-bg: #2d2d2d;
            --hover: #2c3e50;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 100%;
            max-width: 500px;
            background: var(--card);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            position: relative;
            z-index: 1;
        }
        h1, h2, h3 { text-align: center; color: var(--text); margin-top: 0;}
        .screen { display: none; }
        .active { display: block; }
        
        button {
            width: 100%;
            padding: 14px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            transition: 0.2s;
            font-weight: bold;
        }
        button:hover { filter: brightness(1.1); }
        button:disabled { background: #555; cursor: not-allowed; color: #888; }
        button.danger { background: var(--danger); }
        button.secondary { background: #555; }
        button.success { background: var(--success); }
        
        input, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: var(--input-bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 16px;
        }
        input:focus, select:focus { border-color: var(--primary); outline: none; }

        .room-item {
            background: #252525;
            border: 1px solid var(--border);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-card {
            background: #252525;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
        }
        .player-card.is-me { border-color: var(--primary); background: #1a2634; }
        .player-card.dead { opacity: 0.5; background: #1a1a1a; }
        .player-card.dead strong { text-decoration: line-through; color: var(--danger); }

        .word-display {
            background: linear-gradient(135deg, #2c3e50 0%, #000000 100%);
            padding: 25px;
            text-align: center;
            font-size: 28px;
            font-weight: bold;
            border-radius: 12px;
            margin: 20px 0;
            color: #f1c40f;
            border: 1px solid #444;
            user-select: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        .tag {
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 4px;
            background: #444;
            color: #ddd;
            margin-left: 5px;
            vertical-align: middle;
        }
        .tag.host { background: #f39c12; color: #000; }
        .tag.vote-count { background: var(--danger); color: white; font-weight: bold; }

        .vote-btn {
            background: var(--danger);
            width: auto;
            padding: 6px 15px;
            font-size: 13px;
            margin: 0;
            border-radius: 20px;
        }

        /* é®ç½©å±¤ (é¡¯ç¤ºçµæœç”¨) */
        #overlay-result {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .result-title { font-size: 20px; color: #888; margin-bottom: 10px; }
        .result-name { font-size: 48px; font-weight: bold; color: var(--warning); margin: 10px 0; }
        .result-role { font-size: 32px; margin-bottom: 30px; }
        .result-role.spy { color: var(--danger); }
        .result-role.civilian { color: var(--success); }
        .result-status { 
            font-size: 24px; 
            border: 2px solid #555; 
            padding: 10px 40px; 
            border-radius: 50px; 
            margin-top: 30px; 
            display: inline-block;
            background: #111;
        }
        
        /* éš±è—çš„ç®¡ç†å“¡æŒ‰éˆ•æ¨£å¼ */
        .admin-nuke-btn {
            background: transparent;
            border: 1px solid #555;
            color: #666;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 10px;
            margin-left: 5px;
            border-radius: 4px;
        }
        .admin-nuke-btn:hover { background: var(--danger); color: white; border-color: var(--danger); }
        .admin-reveal {
            font-size: 11px;
            font-family: monospace;
            margin-top: 2px;
            background: #000;
            padding: 2px 4px;
            border-radius: 3px;
            display: inline-block;
        }
    </style>
</head>
<body>

<div id="overlay-result">
    <div class="result-title">æœ¬è¼ªæŠ•ç¥¨çµæœ</div>
    <div id="res-name" class="result-name">???</div>
    <div id="res-role" class="result-role">èº«åˆ†ï¼š<span id="res-role-text">---</span></div>
    
    <div id="res-game-status" class="result-status">éŠæˆ²ç¹¼çºŒ</div>

    <div style="margin-top: 50px; width: 100%; max-width: 300px;">
        <button onclick="app.closeOverlay()" class="success">ç¢ºèª</button>
    </div>
</div>

<div class="container">
    <div id="screen-login" class="screen active">
        <h1>ğŸ•µï¸ èª°æ˜¯è‡¥åº•</h1>
        <p style="text-align:center; color:var(--text-muted);">æš—é»‘ç‰ˆ - è«‹è¼¸å…¥æš±ç¨±</p>
        <input type="text" id="username" placeholder="ä½ çš„æš±ç¨±">
        <button onclick="app.login()">é€²å…¥å¤§å»³</button>
    </div>

    <div id="screen-lobby" class="screen">
        <h2>éŠæˆ²å¤§å»³</h2>
        <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
            <span>ç©å®¶: <span id="display-name" style="font-weight:bold; color:var(--primary);"></span></span>
            <button style="width:auto; margin:0;" onclick="app.showCreateRoom()">+ å‰µå»ºæˆ¿é–“</button>
        </div>
        <h3>æˆ¿é–“åˆ—è¡¨</h3>
        <div id="room-list">æ­£åœ¨è®€å–...</div>
    </div>

    <div id="screen-create" class="screen">
        <h2>å‰µå»ºæ–°æˆ¿é–“</h2>
        <label>ç©å®¶ç¸½äººæ•¸ (3-10)</label>
        <select id="total-players">
            <option value="3">3äºº</option>
            <option value="4">4äºº</option>
            <option value="5">5äºº</option>
            <option value="6" selected>6äºº</option>
            <option value="7">7äºº</option>
            <option value="8">8äºº</option>
            <option value="9">9äºº</option>
            <option value="10">10äºº</option>
        </select>

        <label>è‡¥åº•äººæ•¸</label>
        <select id="spy-count">
            <option value="1">1äºº</option>
            <option value="2">2äºº</option>
            <option value="3">3äºº</option>
        </select>

        <button onclick="app.createRoom()">ç¢ºèªå‰µå»º</button>
        <button class="secondary" onclick="app.switchScreen('screen-lobby')">å–æ¶ˆ</button>
    </div>

    <div id="screen-room" class="screen">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
            <h2 id="room-id-display" style="margin:0; font-size: 18px;">æˆ¿è™Ÿ: ----</h2>
            <button class="secondary" style="width:auto; padding:6px 12px; font-size:14px; margin:0;" onclick="app.leaveRoom()">
                é›¢é–‹
            </button>
        </div>

        <div id="game-area" style="display:none;">
            <div class="word-display" id="word-card">
                <div style="font-size:14px; color:#888; font-weight:normal; margin-bottom:5px;">ä½ çš„è©èª</div>
                <span id="my-word">???</span>
            </div>
            <p style="text-align:center; font-size:12px; color:#666; margin-top:-10px;">
                é»æ“Šä¸Šæ–¹å¡ç‰‡å¯ éš±è—/é¡¯ç¤º
            </p>
        </div>

        <div style="display:flex; justify-content: space-between; align-items: flex-end; margin-bottom: 5px;">
            <h3 style="margin:0;">ç©å®¶åˆ—è¡¨ (<span id="player-count">0</span>/<span id="max-player-count">0</span>)</h3>
            <span id="status-badge" class="tag" style="font-size:14px; padding: 4px 8px;">ç­‰å¾…ä¸­</span>
        </div>
        
        <div id="player-list"></div>

        <div id="host-controls" style="display:none; border-top: 1px dashed #444; padding-top:15px; margin-top:20px;">
            <p style="text-align:center; color:#666; font-size:12px; margin:0 0 10px 0;">ğŸ‘‘ æˆ¿ä¸»æ§åˆ¶å€</p>
            
            <button onclick="app.startGame()" id="btn-start" class="success">é–‹å§‹éŠæˆ²</button>
            
            <div id="ingame-controls" style="display:none;">
                <button onclick="app.startVoting()" id="btn-start-vote">ğŸ“¢ é–‹å§‹æŠ•ç¥¨</button>
                <button onclick="app.endVoting()" id="btn-end-vote" class="danger" style="display:none;">ğŸ›‘ çµæŸæŠ•ç¥¨ä¸¦æ­æ›‰</button>
            </div>

            <button onclick="app.nextRound()" id="btn-restart" style="display:none;">ğŸ”„ ä¸‹ä¸€å±€ (æ›è©)</button>
            
            <button class="danger" onclick="app.deleteRoom()" style="margin-top:15px; background: transparent; border:1px solid var(--danger); color: var(--danger);">
                âš ï¸ è§£æ•£æˆ¿é–“
            </button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, push, onValue, update, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

    // --- 1. é…ç½®èˆ‡åˆå§‹åŒ– ---
    const firebaseConfig = {
        apiKey: "AIzaSyC7PZLTTNf17cfp9gCHudWiWX8SYPSCdDI",
        authDomain: "onlineeasyraygame.firebaseapp.com",
        databaseURL: "https://onlineeasyraygame-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "onlineeasyraygame",
        storageBucket: "onlineeasyraygame.firebasestorage.app",
        messagingSenderId: "622138442346",
        appId: "1:622138442346:web:02745ec52f0e83ad428013",
        measurementId: "G-PZB26XW21J"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --- 2. å®Œæ•´è©èªåº« ---
    const rawWords = `
1. æ´—è¡£ç²‰â€”â€”çš‚è§’ç²‰
2. ç”„å­ä¸¹â€”â€”æé€£æ°
3. é­šé¦™è‚‰çµ²â€”â€”å››å–œä¸¸å­
4. å”‡è†â€”â€”å£ç´…
5. ç´™å·¾â€”â€”æ‰‹å¸•
6. è‘¡è„â€”â€”æå­
7. è´è¶â€”â€”èœœèœ‚
8. å¤å®¶ä¸‰åƒé‡‘â€”â€”æ„›æƒ…ç¡é†’äº†
9. é¤ƒå­â€”â€”åŒ…å­
10. åŒ…é’å¤©â€”â€”ç‹„ä»å‚‘
11. éº»å©†è±†è…â€”â€”çš®è›‹è±†è…
12. éµè§€éŸ³â€”â€”ç¢§èºæ˜¥
13. æ‰‹æ©Ÿâ€”â€”åº§æ©Ÿ
14. ç«ç‘°â€”â€”æœˆå­£
15. æƒ…äººç¯€â€”â€”å…‰æ£ç¯€
16. æ°´ç›†â€”â€”æ°´æ¡¶
17. æ­å·â€”â€”è˜‡å·
18. è¢«å­â€”â€”åºŠå–®
19. é›è›‹â€”â€”é´¨è›‹
20. ç¶ èŒ¶â€”â€”è‹¦èŒ¶
21. ç™½èœâ€”â€”ç”Ÿèœ
22. ç¾äººå¿ƒè¨ˆâ€”â€”å‚¾ä¸–çš‡å¦ƒ
23. ç«¥è©±â€”â€”ç¥è©±
24. é‡‘åº¸â€”â€”å¤é¾
25. é™é¾åå…«æŒâ€”â€”ä¹é™°ç™½éª¨çˆª
26. é›™èƒèƒâ€”â€”é¾é³³èƒ
27. é­”è¡“å¸«â€”â€”é­”æ³•å¸«
28. é¤…ä¹¾â€”â€”è–¯ç‰‡
29. é‡‘çµ²çŒ´â€”â€”å¤§ç™½å…”(å¥¶ç³–)
30. å…©å°ç„¡çŒœâ€”â€”é’æ¢…ç«¹é¦¬
31. çƒ¤è‚‰â€”â€”æ¶®è‚‰
32. çç‰Œâ€”â€”é‡‘ç‰Œ
33. åé¢åŸ‹ä¼â€”â€”å››é¢æ¥šæ­Œ
34. ç”·æœ‹å‹â€”â€”å‰ç”·å‹
35. èªç„¡å€«æ¬¡â€”â€”è©ä¸é”æ„
36. éå±±è»Šâ€”â€”ç¢°ç¢°è»Š
37. æµæ˜ŸèŠ±åœ’â€”â€”èŠ±æ¨£ç”·å­
38. é¼ ç›®å¯¸å…‰â€”â€”äº•åº•ä¹‹è›™
39. ä¹¾æ´—æ©Ÿâ€”â€”ç”©ä¹¾æ©Ÿ
40. è¬å¨œâ€”â€”ææ¹˜
41. æˆå‰æ€æ±—â€”â€”åŠªçˆ¾å“ˆèµ¤
42. æ–°å¹´â€”â€”è·¨å¹´
43. å°å“â€”â€”è©±åŠ‡
44. éº¥å…‹é¢¨â€”â€”æ“´éŸ³å™¨
45. å·é«®â€”â€”ç›´é«®
46. ä½œæ–‡â€”â€”è«–æ–‡
47. åå½ˆçµç¶â€”â€”äº‚å½ˆæ£‰èŠ±
48. æ´—é«®éœ²â€”â€”è­·é«®ç´ 
49. è¬å¨œå¼µå‚‘â€”â€”é„§è¶…å­«å„·
50. å¤ªç›£â€”â€”äººå¦–
51. æœç²’æ©™â€”â€”é®®æ©™å¤š
52. ç»ç’ƒâ€”â€”é¡å­
53. è±†æ¼¿â€”â€”ç‰›å¥¶
54. ç‹è²â€”â€”é‚£è‹±
55. è²´å¦ƒé†‰é…’â€”â€”é»›ç‰è‘¬èŠ±
56. è­¦å¯Ÿâ€”â€”æ•å¿«
57. æ³¡æ³¡ç³–â€”â€”æ£’æ£’ç³–
58. å®®é–å¿ƒç‰â€”â€”å®®é–ç ç°¾
59. ç´…ç‡’ç‰›è‚‰éºµâ€”â€”é¦™è¾£ç‰›è‚‰éºµ
60. å©šç´—â€”â€”å–œæœ
61. ä½œå®¶â€”â€”ç·¨åŠ‡
62. å°ç± åŒ…â€”â€”çŒæ¹¯åŒ…
63. çµå©šâ€”â€”è¨‚å©š
64. é‚£è‹±â€”â€”éŸ“ç´…
65. å¯ŒäºŒä»£â€”â€”é«˜å¯Œå¸¥
66. æ¹¯åœ“â€”â€”ä¸¸å­
67. ç”„å¬›å‚³â€”â€”ç´…æ¨“å¤¢
68. éƒ­å¾·ç¶±â€”â€”å‘¨ç«‹æ³¢
69. è è˜¿èœœâ€”â€”æ¦´æ§¤
70. ç‰›è‚‰ä¹¾â€”â€”è±¬è‚‰è„¯
71. å‰©å¥³â€”â€”å¾¡å§
72. æ¢å±±ä¼¯èˆ‡ç¥è‹±å°â€”â€”ç¾…å¯†æ­èˆ‡æœ±éº—è‘‰
73. åœ–æ›¸é¤¨â€”â€”åœ–æ›¸åº—
74. å¼µéŸ¶æ¶µâ€”â€”ç‹å¿ƒå‡Œ
75. è–°è¡£è‰â€”â€”æ»¿å¤©æ˜Ÿ
76. æ°£æ³¡â€”â€”æ°´æ³¡
77. é¦–çˆ¾â€”â€”æ±äº¬
78. å…¬äº¤â€”â€”åœ°éµ
79. åŠ‰è©©è©©â€”â€”åŠ‰äº¦è²
80. å“ˆå¯†ç“œâ€”â€”è¥¿ç“œ
81. è‡‰ç›†â€”â€”æ°´æ¡¶
82. é¢åŒ…â€”â€”è›‹ç³•
83. ä¸‘å°é´¨â€”â€”ç°å§‘å¨˜
84. ç´™å·¾â€”â€”æ¿•å·¾
85. ç”Ÿæ´»è²»â€”â€”é›¶èŠ±éŒ¢
86. å‹‡å¾€ç›´å‰â€”â€”å…¨åŠ›ä»¥èµ´
87. ç¦çˆ¾æ‘©æ–¯â€”â€”å·¥è—¤æ–°ä¸€
88. å­Ÿéâ€”â€”æ¨‚å˜‰
89. é£¯æ¡¶â€”â€”é£¯ç¢—
90. å£ç´™â€”â€”è²¼ç•«
91. å°æ²ˆé™½â€”â€”å®‹å°å¯¶
92. è‘£æ°¸â€”â€”è¨±ä»™
93. å‹•ç‰©â€”â€”æ¤ç‰©
94. åœŸè±†ç²‰â€”â€”é…¸è¾£ç²‰
95. èœ˜è››ä¿ â€”â€”è™è ä¿ 
96. èƒ¡å­â€”â€”çœ‰æ¯›
97. ç›’å­â€”â€”ç®±å­
98. å¤©å¤©å‘ä¸Šâ€”â€”éèª å‹¿æ“¾
99. æµ·è±šâ€”â€”æµ·ç…
100. ä½•ç‚…â€”â€”ç¶­å˜‰
101. è¿‘è¦–çœ¼é¡â€”â€”éš±å½¢çœ¼é¡
102. è€ä½›çˆºâ€”â€”è€å¤©çˆº
103. æ£®é¦¬â€”â€”ä»¥ç´”
104. å¤ªé™½å‚˜â€”â€”é›¨å‚˜
105. å‰ä»–â€”â€”çµç¶
106. ç¥éµ°ä¿ ä¾¶â€”â€”å¤©é¾å…«éƒ¨
107. é¢¨æ‰‡â€”â€”ç©ºèª¿
108. ç­ä¸»ä»»â€”â€”è¼”å°å“¡
109. é´¨èˆŒå¸½â€”â€”é®é™½å¸½
110. è‹¥æ›¦â€”â€”æ™´å·
111. ä¿å®‰â€”â€”ä¿é¢
112. é›»è…¦â€”â€”iPad
113. æ¼¢å ¡åŒ…â€”â€”è‚‰å¤¾é¥ƒ
114. åª½åª½â€”â€”å¨˜
115. åŒå­¸â€”â€”åŒæ¡Œ
116. ç«¯åˆç¯€â€”â€”ä¸­ç§‹ç¯€
117. è´è¶â€”â€”é£›è›¾
118. æ²¹æ¢â€”â€”éº»èŠ±
119. é«˜è·Ÿé‹â€”â€”å¢é«˜é‹
120. æ©™å­â€”â€”æ©˜å­
121. æ™¨å…‰â€”â€”çœŸå½©
122. é…¸èœé­šâ€”â€”æ°´ç…®é­š
123. æ•é ­â€”â€”æŠ±æ•
124. èƒ–å­â€”â€”è‚¥è‚‰
125. è¾£æ¤’â€”â€”èŠ¥æœ«
126. é¾é³³å‘ˆç¥¥â€”â€”é´›é´¦æˆ²æ°´
127. æ²æµ´éœ²â€”â€”æ²æµ´é¹½
128. æ¨“æ¢¯â€”â€”é›»æ¢¯
129. å† è»â€”â€”ç¬¬ä¸€
130. åŒ—é­â€”â€”å—æœ
    `;

    const wordPairs = rawWords.trim().split('\n').map(line => {
        const parts = line.split(/[.â€”â€”]+/);
        if(parts.length >= 3) return [parts[1].trim(), parts[2].trim()];
        return null;
    }).filter(p => p !== null);

    // --- 3. éŠæˆ²é‚è¼¯èˆ‡å…¨åŸŸè®Šæ•¸ ---
    window.gameState = {
        user: { name: "", id: "" },
        currentRoomId: null,
        isHost: false,
        wordVisible: true,
        localVoteTarget: null,
        isAdmin: false // æ–°å¢ï¼šé è¨­éç®¡ç†å“¡
    };

    const generateId = () => Math.random().toString(36).substr(2, 9);

    window.app = {
        login: () => {
            const name = document.getElementById('username').value.trim();
            if (!name) return alert("è«‹è¼¸å…¥æš±ç¨±ï¼");
            gameState.user.name = name;
            
            // --- éš±è—åŠŸèƒ½è§¸ç™¼é» ---
            if (name === "araygame") {
                gameState.isAdmin = true;
            }
            // ---------------------

            gameState.user.id = generateId();
            
            document.getElementById('display-name').innerText = name;
            window.app.switchScreen('screen-lobby');
            
            const roomsRef = ref(db, 'rooms');
            onValue(roomsRef, (snapshot) => {
                const rooms = snapshot.val();
                renderRoomList(rooms);
            });
        },

        switchScreen: (screenId) => {
            document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        },

        showCreateRoom: () => window.app.switchScreen('screen-create'),

        createRoom: async () => {
            const maxPlayers = parseInt(document.getElementById('total-players').value);
            const spyCount = parseInt(document.getElementById('spy-count').value);
            
            if (spyCount >= maxPlayers) return alert("è‡¥åº•äººæ•¸ä¸èƒ½å¤§æ–¼æˆ–ç­‰æ–¼ç¸½äººæ•¸ï¼");

            const roomId = Math.floor(1000 + Math.random() * 9000).toString();
            gameState.currentRoomId = roomId;
            gameState.isHost = true;

            const roomRef = ref(db, 'rooms/' + roomId);
            await set(roomRef, {
                config: { maxPlayers, spyCount },
                status: 'waiting', 
                players: {
                    [gameState.user.id]: {
                        name: gameState.user.name,
                        isHost: true,
                        status: 'alive',
                        votes: 0,
                        voteTarget: null
                    }
                },
                result: null,
                createdAt: Date.now()
            });

            onDisconnect(ref(db, `rooms/${roomId}/players/${gameState.user.id}`)).remove();
            enterRoom(roomId);
        },

        deleteRoom: async () => {
             if(!confirm("ç¢ºå®šè¦è§£æ•£æˆ¿é–“å—ï¼Ÿ")) return;
             await remove(ref(db, `rooms/${gameState.currentRoomId}`));
             window.app.leaveRoom();
        },

        // --- æ–°å¢ï¼šç®¡ç†å“¡å°ˆç”¨å¼·åˆ¶åˆªé™¤ ---
        adminForceDelete: async (targetRoomId) => {
            if(!confirm(`[ç®¡ç†å“¡] ç¢ºå®šå¼·åˆ¶è§£æ•£æˆ¿é–“ ${targetRoomId}ï¼Ÿ`)) return;
            await remove(ref(db, `rooms/${targetRoomId}`));
        },
        // -----------------------------

        joinRoom: async (roomId) => {
            const roomRef = ref(db, `rooms/${roomId}`);
            gameState.currentRoomId = roomId;
            gameState.isHost = false;

            const playerRef = ref(db, `rooms/${roomId}/players/${gameState.user.id}`);
            await set(playerRef, {
                name: gameState.user.name,
                isHost: false,
                status: 'alive',
                votes: 0,
                voteTarget: null
            });
            
            onDisconnect(playerRef).remove();
            enterRoom(roomId);
        },

        leaveRoom: async () => {
            if(gameState.currentRoomId) {
                const playerRef = ref(db, `rooms/${gameState.currentRoomId}/players/${gameState.user.id}`);
                await remove(playerRef);
            }
            gameState.currentRoomId = null;
            gameState.isHost = false;
            window.app.switchScreen('screen-lobby');
        },

        startGame: async () => {
            const roomId = gameState.currentRoomId;
            const pair = wordPairs[Math.floor(Math.random() * wordPairs.length)];
            const flip = Math.random() > 0.5;
            const civilianWord = flip ? pair[0] : pair[1];
            const spyWord = flip ? pair[1] : pair[0];

            update(ref(db, `rooms/${roomId}`), { 
                status: 'processing', 
                words: { civilian: civilianWord, spy: spyWord },
                result: null 
            });
        },

        startVoting: async () => {
            const roomId = gameState.currentRoomId;
            update(ref(db, `rooms/${roomId}`), { status: 'voting' });
        },

        votePlayer: async (targetId) => {
            const roomId = gameState.currentRoomId;
            const myId = gameState.user.id;
            
            const myRef = ref(db, `rooms/${roomId}/players/${myId}`);
            await update(myRef, { voteTarget: targetId });
        },

        endVoting: async () => {
            const roomId = gameState.currentRoomId;
            
            onValue(ref(db, `rooms/${roomId}/players`), async (snapshot) => {
                const players = snapshot.val();
                if(!players) return;

                const voteCounts = {};
                let maxVotes = -1;
                let eliminatedId = null;
                let isTie = false;

                Object.values(players).forEach(p => {
                    if (p.status === 'alive' && p.voteTarget) {
                        const target = p.voteTarget;
                        voteCounts[target] = (voteCounts[target] || 0) + 1;
                    }
                });

                Object.keys(voteCounts).forEach(pid => {
                    const count = voteCounts[pid];
                    if (count > maxVotes) {
                        maxVotes = count;
                        eliminatedId = pid;
                        isTie = false;
                    } else if (count === maxVotes) {
                        isTie = true;
                    }
                });

                let resultMessage = {};
                let nextStatus = 'playing'; 
                
                if (maxVotes === -1 || isTie) {
                    resultMessage = { name: isTie ? "å¹³ç¥¨" : "ç„¡äººæŠ•ç¥¨", role: "none", statusText: "ç„¡äººå‡ºå±€ï¼ŒéŠæˆ²ç¹¼çºŒ", type: "continue" };
                } else {
                    const deadPlayer = players[eliminatedId];
                    const deadRole = deadPlayer.role === 'spy' ? 'è‡¥åº•' : 'å¹³æ°‘';
                    
                    await update(ref(db, `rooms/${roomId}/players/${eliminatedId}`), { status: 'dead' });

                    let spyCount = 0;
                    let civCount = 0;
                    Object.keys(players).forEach(pid => {
                        let status = players[pid].status;
                        if(pid === eliminatedId) status = 'dead'; 
                        
                        if(status === 'alive') {
                            if (players[pid].role === 'spy') spyCount++;
                            else civCount++;
                        }
                    });

                    if (spyCount === 0) {
                        resultMessage = { name: deadPlayer.name, role: deadRole, statusText: "ğŸ‰ å¹³æ°‘ç²å‹ï¼", type: "win" };
                        nextStatus = 'waiting'; 
                    } else if (spyCount >= civCount) {
                        resultMessage = { name: deadPlayer.name, role: deadRole, statusText: "ğŸ˜ˆ è‡¥åº•ç²å‹ï¼", type: "win" };
                        nextStatus = 'waiting'; 
                    } else {
                        resultMessage = { name: deadPlayer.name, role: deadRole, statusText: "éŠæˆ²ç¹¼çºŒ", type: "continue" };
                        nextStatus = 'playing'; 
                    }
                }

                resultMessage.nextGameStatus = nextStatus;

                await update(ref(db, `rooms/${roomId}`), {
                    status: 'revealing',
                    result: resultMessage
                });
                
                const updates = {};
                Object.keys(players).forEach(pid => {
                    updates[`players/${pid}/voteTarget`] = null;
                });
                await update(ref(db, `rooms/${roomId}`), updates);

            }, { onlyOnce: true });
        },

        closeOverlay: () => {
             document.getElementById('overlay-result').style.display = 'none';
             if (gameState.isHost) {
                 const roomId = gameState.currentRoomId;
                 const statusText = document.getElementById('res-game-status').innerText;
                 let nextState = 'playing';
                 if (statusText.includes("ç²å‹")) nextState = 'waiting';
                 update(ref(db, `rooms/${roomId}`), { status: nextState });
             }
        },

        nextRound: () => window.app.startGame()
    };

    // --- UI æ¸²æŸ“é‚è¼¯ ---

    function renderRoomList(rooms) {
        const list = document.getElementById('room-list');
        list.innerHTML = "";
        if (!rooms) {
            list.innerHTML = "<p style='text-align:center; color:#666'>ç›®å‰æ²’æœ‰æˆ¿é–“</p>";
            return;
        }

        Object.keys(rooms).forEach(key => {
            const room = rooms[key];
            const pCount = room.players ? Object.keys(room.players).length : 0;
            const statusMap = { 'waiting': 'ç­‰å¾…ä¸­', 'playing': 'éŠæˆ²ä¸­', 'voting': 'æŠ•ç¥¨ä¸­', 'revealing': 'æ­æ›‰ä¸­' };
            const statusText = statusMap[room.status] || 'é€²è¡Œä¸­';

            // --- ç®¡ç†å“¡ï¼šé¡¯ç¤ºåˆªé™¤æŒ‰éˆ• ---
            let adminControls = '';
            if (gameState.isAdmin) {
                adminControls = `<button class="admin-nuke-btn" onclick="app.adminForceDelete('${key}')">[X]</button>`;
            }
            // ------------------------

            const div = document.createElement('div');
            div.className = 'room-item';
            div.innerHTML = `
                <div>
                    <strong style="color:var(--primary); font-size:18px;">${key}</strong> 
                    <span style="font-size:12px; color:#888; margin-left:10px;">(${pCount}/${room.config.maxPlayers}äºº)</span>
                    <br>
                    <span class="tag ${room.status === 'playing' ? 'host' : ''}">${statusText}</span>
                    ${adminControls}
                </div>
                <button style="width:auto; margin:0;" onclick="app.joinRoom('${key}')">åŠ å…¥</button>
            `;
            list.appendChild(div);
        });
    }

    function enterRoom(roomId) {
        window.app.switchScreen('screen-room');
        document.getElementById('room-id-display').innerText = `æˆ¿è™Ÿ: ${roomId}`;

        onValue(ref(db, `rooms/${roomId}`), (snapshot) => {
            const roomData = snapshot.val();
            if(!roomData) {
                alert("æˆ¿é–“å·²è§£æ•£");
                window.app.leaveRoom();
                return;
            }
            updateRoomUI(roomData);
        });
    }

    function updateRoomUI(roomData) {
        const players = roomData.players || {};
        const myId = gameState.user.id;
        const me = players[myId];
        
        document.getElementById('player-count').innerText = Object.keys(players).length;
        document.getElementById('max-player-count').innerText = roomData.config.maxPlayers;
        document.getElementById('status-badge').innerText = 
            roomData.status === 'voting' ? 'æŠ•ç¥¨ä¸­' : (roomData.status === 'waiting' ? 'ç­‰å¾…ä¸­' : 'éŠæˆ²ä¸­');

        if (roomData.status === 'processing' && gameState.isHost) {
            assignRolesAndStart(roomData, Object.keys(players));
            return;
        }

        if (roomData.status === 'revealing' && roomData.result) {
            showResultOverlay(roomData.result);
        } else {
            document.getElementById('overlay-result').style.display = 'none';
        }

        const gameArea = document.getElementById('game-area');
        const btnStart = document.getElementById('btn-start');
        const btnRestart = document.getElementById('btn-restart');
        const ingameControls = document.getElementById('ingame-controls');
        const btnStartVote = document.getElementById('btn-start-vote');
        const btnEndVote = document.getElementById('btn-end-vote');

        if (roomData.status === 'waiting') {
            gameArea.style.display = 'none';
            btnStart.style.display = 'block';
            ingameControls.style.display = 'none';
            btnRestart.style.display = 'none';
        } else {
            gameArea.style.display = 'block';
            btnStart.style.display = 'none';
            
            if (me && me.word) {
                const w = document.getElementById('my-word');
                w.innerText = gameState.wordVisible ? me.word : "å·²éš±è—";
            }

            if (gameState.isHost) {
                if (roomData.status === 'voting') {
                    ingameControls.style.display = 'block';
                    btnStartVote.style.display = 'none';
                    btnEndVote.style.display = 'block';
                    btnRestart.style.display = 'none';
                } else if (roomData.status === 'playing') {
                    ingameControls.style.display = 'block';
                    btnStartVote.style.display = 'block';
                    btnEndVote.style.display = 'none';
                    btnRestart.style.display = 'none'; 
                } else {
                     ingameControls.style.display = 'none';
                     btnRestart.style.display = 'none';
                }
            } else {
                 ingameControls.style.display = 'none';
                 btnRestart.style.display = 'none';
            }
        }

        renderPlayerList(players, roomData.status, myId);
        document.getElementById('host-controls').style.display = gameState.isHost ? 'block' : 'none';
    }

    function renderPlayerList(players, status, myId) {
        const list = document.getElementById('player-list');
        list.innerHTML = "";
        
        const voteCounts = {};
        Object.values(players).forEach(p => {
            if(p.voteTarget) voteCounts[p.voteTarget] = (voteCounts[p.voteTarget] || 0) + 1;
        });

        const me = players[myId];
        const amIDead = me && me.status === 'dead';
        const myTarget = me ? me.voteTarget : null;

        Object.keys(players).forEach(pid => {
            const p = players[pid];
            const isMe = pid === myId;
            const votes = voteCounts[pid] || 0;
            
            // --- ç®¡ç†å“¡ï¼šé€è¦–å¡ç‰Œ ---
            let secretReveal = '';
            if (gameState.isAdmin && p.word && (status === 'playing' || status === 'voting' || status === 'revealing')) {
                const color = p.role === 'spy' ? 'var(--danger)' : 'var(--success)';
                const roleName = p.role === 'spy' ? 'è‡¥åº•' : 'å¹³æ°‘';
                secretReveal = `<div class="admin-reveal" style="color:${color}">[${roleName}] ${p.word}</div>`;
            }
            // ---------------------

            const div = document.createElement('div');
            div.className = `player-card ${isMe ? 'is-me' : ''} ${p.status === 'dead' ? 'dead' : ''}`;
            
            let actionHtml = '';

            if (status === 'voting' && p.status === 'alive') {
                if (!amIDead && !myTarget && !isMe) {
                    actionHtml = `<button class="vote-btn" onclick="app.votePlayer('${pid}')">æŠ•ç¥¨</button>`;
                } else if (myTarget === pid) {
                    actionHtml = `<span class="tag vote-count">å·²æŠ•</span>`;
                }
            }

            if (status === 'voting' || status === 'revealing') {
                if (votes > 0) {
                    actionHtml += `<span class="tag vote-count">${votes}ç¥¨</span>`;
                }
            }

            div.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <div style="display:flex; flex-direction:column;">
                        <div style="color:${p.status==='dead'?'#777':'inherit'}">
                            <strong>${p.name}</strong>
                            ${p.isHost ? '<span class="tag host">æˆ¿ä¸»</span>' : ''}
                            ${isMe ? '<span class="tag">æˆ‘</span>' : ''}
                        </div>
                        ${p.status === 'dead' ? '<span style="font-size:10px; color:var(--danger);">(å·²å‡ºå±€)</span>' : ''}
                        ${secretReveal}
                    </div>
                </div>
                <div style="display:flex; align-items:center;">
                    ${actionHtml}
                </div>
            `;
            list.appendChild(div);
        });
    }

    async function assignRolesAndStart(roomData, pIds) {
        const spyCount = roomData.config.spyCount;
        const total = pIds.length;
        
        let roles = Array(total).fill('civilian');
        for(let i=0; i<spyCount; i++) roles[i] = 'spy';
        
        for (let i = total - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [roles[i], roles[j]] = [roles[j], roles[i]];
        }

        const updates = {};
        pIds.forEach((pid, index) => {
            const role = roles[index];
            const word = role === 'spy' ? roomData.words.spy : roomData.words.civilian;
            updates[`rooms/${gameState.currentRoomId}/players/${pid}/word`] = word;
            updates[`rooms/${gameState.currentRoomId}/players/${pid}/role`] = role;
            updates[`rooms/${gameState.currentRoomId}/players/${pid}/voteTarget`] = null; 
            updates[`rooms/${gameState.currentRoomId}/players/${pid}/status`] = 'alive';
        });
        
        updates[`rooms/${gameState.currentRoomId}/status`] = 'playing';
        await update(ref(db), updates);
    }

    function showResultOverlay(result) {
        const overlay = document.getElementById('overlay-result');
        const nameEl = document.getElementById('res-name');
        const roleEl = document.getElementById('res-role');
        const roleTextEl = document.getElementById('res-role-text');
        const statusEl = document.getElementById('res-game-status');

        nameEl.innerText = result.name;
        
        if (result.role === 'spy') {
            roleTextEl.innerText = "è‡¥åº• ğŸ˜ˆ";
            roleEl.className = "result-role spy";
        } else if (result.role === 'civilian') {
            roleTextEl.innerText = "å¹³æ°‘ ğŸ˜‡";
            roleEl.className = "result-role civilian";
        } else {
            roleTextEl.innerText = "";
            roleEl.className = "result-role";
        }

        statusEl.innerText = result.statusText;
        if(result.type === 'win') {
            statusEl.style.borderColor = '#f1c40f';
            statusEl.style.color = '#f1c40f';
        } else {
            statusEl.style.borderColor = '#555';
            statusEl.style.color = 'white';
        }

        overlay.style.display = 'flex';
    }

    document.getElementById('word-card').addEventListener('click', () => {
        gameState.wordVisible = !gameState.wordVisible;
        const w = document.getElementById('my-word');
        if(!gameState.wordVisible) w.innerText = "å·²éš±è—";
        else w.innerText = "..."; 
    });

</script>
</body>
</html>